                        ` : ''}
                        ${state.isGameActive ? `
                            <div class="w-16 h-16 inline-block">
                                <svg class="animate-spin w-full h-full text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Bet Amount Selector -->
                    <div class="w-full mb-6">
                        <label for="roulette-bet" class="block text-sm font-medium text-cyan-300 mb-2">Set Bet Amount (Min: ${MIN_BET} Tokens, Max: ${state.balance} Tokens)</label>
                        <input
                            type="number"
                            id="roulette-bet"
                            min="${MIN_BET}"
                            max="${state.balance}"
                            value="${BET_AMOUNT}"
                            oninput="window.setRouletteBet(this.value)"
                            ${state.isGameActive ? 'disabled' : ''}
                            class="w-full p-3 rounded-lg bg-slate-700 text-white border border-slate-600 focus:border-cyan-400 focus:ring-cyan-400 disabled:bg-slate-700/50"
                        />
                    </div>
                    
                    <!-- Message Area (Fixed height above buttons) -->
                    <div class="w-full mb-4 text-center h-10 flex flex-col justify-center">
                        <p id="roulette-message" class="text-lg font-semibold text-white">${message}</p>
                    </div>

                    <!-- Bet Buttons -->
                    <div class="flex space-x-4 w-full">
                        <button
                            onclick="window.handleBetRoulette('red')"
                            ${state.isGameActive || isInvalidBet ? 'disabled' : ''}
                            class="flex-1 py-3 bg-red-600 hover:bg-red-700 text-white text-xl font-extrabold rounded-lg transition-all duration-200 shadow-md disabled:bg-slate-500 disabled:cursor-not-allowed"
                        >
                            BET RED (${BET_AMOUNT} Tokens)
                        </button>
                        <button
                            onclick="window.handleBetRoulette('black')"
                            ${state.isGameActive || isInvalidBet ? 'disabled' : ''}
                            class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white text-xl font-extrabold rounded-lg transition-all duration-200 shadow-md disabled:bg-slate-500 disabled:cursor-not-allowed"
                        >
                            BET BLACK (${BET_AMOUNT} Tokens)
                        </button>
                    </div>
                    <p class="mt-4 text-sm text-cyan-300/80">Green (0) pays 17:1, but is not available to bet on.</p>
                </div>
            `;
        };

        // --- Game Logic (Attached to window for easy access from HTML) ---

        window.setSlotsBet = (value) => {
            const bet = parseInt(value, 10);
            const MIN_BET = 10;
            
            // Only update if it's a valid number. Clamp it at 0 minimum.
            let newBet = isNaN(bet) || bet < 0 ? 0 : bet;
            if (newBet > 0 && newBet < MIN_BET) newBet = MIN_BET; // Enforce minimum if they enter something low but positive
            
            updateState({ slotsBetAmount: newBet, slotsMessage: newBet < MIN_BET ? `Minimum bet is ${MIN_BET} Tokens.` : `Current Bet: ${newBet} Tokens` });
        };
        
        window.setDiceBet = (value) => {
            const bet = parseInt(value, 10);
            const MIN_BET = 5; 
            
            let newBet = isNaN(bet) || bet < 0 ? 0 : bet;
            if (newBet > 0 && newBet < MIN_BET) newBet = MIN_BET;

            updateState({ diceBetAmount: newBet, diceMessage: newBet < MIN_BET ? `Minimum bet is ${MIN_BET} Tokens.` : `Current Bet: ${newBet} Tokens` });
        };

        window.setRouletteBet = (value) => {
            const bet = parseInt(value, 10);
            const MIN_BET = 10;
            
            // Only update if it's a valid positive number, otherwise default to min or 0 if empty
            let newBet = isNaN(bet) || bet < 0 ? 0 : bet;
            if (newBet > 0 && newBet < MIN_BET) newBet = MIN_BET;
            
            // Ensure UI updates reflect the new bet amount and state
            updateState({ rouletteBetAmount: newBet, rouletteMessage: newBet < MIN_BET ? `Minimum bet is ${MIN_BET} Tokens.` : `Current Bet: ${newBet} Tokens` });
        };


        window.spinSlots = () => {
            const symbols = ['üçí', 'üçã', 'üîî', '‚≠ê', 'üíé'];
            const BET_AMOUNT = state.slotsBetAmount;
            const MIN_BET = 10;
            
            if (BET_AMOUNT < MIN_BET) {
                updateState({ slotsMessage: `Minimum bet is ${MIN_BET} Tokens.` });
                return;
            }

            if (state.balance < BET_AMOUNT || state.isGameActive) {
                updateState({ slotsMessage: state.balance < BET_AMOUNT ? 'Insufficient funds for this bet!' : 'Wait for the spin to finish.' });
                return;
            }
        
            updateState({ isGameActive: true, slotsMessage: `Spinning ${BET_AMOUNT} Tokens...`, slotsReels: ['?', '?', '?'] });
            updateFunds(-BET_AMOUNT); 
        
            let spinCount = 0;
            const interval = setInterval(() => {
                const newReels = symbols.map(() => symbols[Math.floor(Math.random() * symbols.length)]);
                updateState({ slotsReels: newReels }); 
                spinCount++;
        
                if (spinCount > 20) {
                    clearInterval(interval);
                    const finalReels = [
                        symbols[Math.floor(Math.random() * symbols.length)],
                        symbols[Math.floor(Math.random() * symbols.length)],
                        symbols[Math.floor(Math.random() * symbols.length)],
                    ];
                    updateState({ slotsReels: finalReels });
                    determineSlotWin(finalReels);
                }
            }, 100);
        };
        
        const determineSlotWin = (finalReels) => {
            const [r1, r2, r3] = finalReels;
            const BET_AMOUNT = state.slotsBetAmount; 
            let profit = 0;
            let message;
        
            if (r1 === r2 && r2 === r3) {
                profit = BET_AMOUNT * 9; // 10x total return (9x profit)
                message = `JACKPOT! Three ${r1}s! You won ${profit + BET_AMOUNT} Tokens! (Profit: ${profit} Tokens)`;
            } else if (r1 === r2 || r2 === r3 || r1 === r3) {
                profit = BET_AMOUNT * 1; // 2x total return (1x profit)
                message = `Two matched! You won ${profit + BET_AMOUNT} Tokens! (Profit: ${profit} Tokens)`;
            } else {
                message = 'No match. Try again!';
            }
        
            updateState({ slotsMessage: message, isGameActive: false });

            if (profit > 0) {
                // Return original bet + profit
                updateFunds(profit + BET_AMOUNT); 
            }
        };

        window.handleBetRoulette = (color) => {
            const BET_AMOUNT = state.rouletteBetAmount;
            const MIN_BET = 10;
            const outcomes = {
                0: { color: 'green', text: '0' },
                1: { color: 'red', text: '1' },
                2: { color: 'black', text: '2' },
                3: { color: 'red', text: '3' },
                4: { color: 'black', text: '4' },
            };

            if (state.isGameActive) {
                updateState({ rouletteMessage: 'Wait for the roll to finish.' });
                return;
            }

            if (BET_AMOUNT < MIN_BET || state.balance < BET_AMOUNT) {
                 updateState({ rouletteMessage: BET_AMOUNT < MIN_BET ? `Minimum bet is ${MIN_BET} Tokens.` : 'Insufficient funds for this bet!' });
                return;
            }

            updateState({ 
                isGameActive: true, 
                rouletteMessage: `Betting ${BET_AMOUNT} Tokens on ${color.toUpperCase()}...`,
                rouletteResult: null,
                rouletteBet: color
            });
            updateFunds(-BET_AMOUNT);

            setTimeout(() => {
                const winningNumber = Math.floor(Math.random() * 5); // 0-4
                const winningOutcome = outcomes[winningNumber];
                
                let winnings = 0; // Total return (bet + profit)
                let message;

                if (winningOutcome.color === 'green') {
                    message = `The ball landed on GREEN (${winningOutcome.text})! You lost your bet.`;
                } else if (winningOutcome.color === color) {
                    winnings = 2 * BET_AMOUNT; // 1:1 payout (Total return: 2x bet)
                    message = `The ball landed on ${winningOutcome.color.toUpperCase()} (${winningOutcome.text})! You won ${BET_AMOUNT} Tokens profit!`;
                    updateFunds(winnings);
                } else {
                    message = `The ball landed on ${winningOutcome.color.toUpperCase()} (${winningOutcome.text}). Better luck next time.`;
                }

                updateState({ 
                    rouletteResult: winningOutcome, 
                    rouletteMessage: message, 
                    isGameActive: false 
                });
            }, 3000);
        };

        window.rollDice = (guess) => {
            const BET_AMOUNT = state.diceBetAmount;
            const MIN_BET = 5;

            if (BET_AMOUNT < MIN_BET) {
                updateState({ diceMessage: `Minimum bet is ${MIN_BET} Tokens.` });
                return;
            }
            
            if (state.balance < BET_AMOUNT || state.isGameActive) {
                updateState({ diceMessage: state.balance < BET_AMOUNT ? 'Insufficient funds for this bet!' : 'Wait for the roll to finish.' });
                return;
            }

            updateState({ 
                isGameActive: true, 
                diceMessage: `Betting ${BET_AMOUNT} Tokens on ${guess}...`,
                diceRollResult: null
            });
            updateFunds(-BET_AMOUNT); 

            setTimeout(() => {
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const sum = die1 + die2;
                const rollResult = { die1, die2, sum };

                const isHigh = sum >= 7;
                const winCondition = (guess === 'HIGH' && isHigh) || (guess === 'LOW' && !isHigh);
                let winnings = 0; // Total return (bet + profit)
                let message;

                if (winCondition) {
                    winnings = 2 * BET_AMOUNT; // 1:1 payout (Total return: 2x bet)
                    message = `Rolled a ${sum} (${die1} + ${die2}). You guessed ${guess} and WON ${BET_AMOUNT} Tokens profit!`;
                    updateFunds(winnings);
                } else {
                    message = `Rolled a ${sum} (${die1} + ${die2}). You guessed ${guess} and LOST. Try again!`;
                }

                updateState({ diceRollResult: rollResult, diceMessage: message, isGameActive: false });
            }, 2000);
        };

        window.setCurrentGame = (gameName) => {
            updateState({ currentGame: gameName, isGameActive: false });
        };


        // --- Main Render Function ---
        const renderApp = () => {
            let gameContent = '';
            // --- UPDATED HEADER WITH SPACE IN "Big Nickel" and new colors ---
            let header = `
                <header class="mb-8 text-center">
                    <h1 class="font-display text-5xl sm:text-6xl text-cyan-400 uppercase tracking-[0.1em] border-b-4 border-cyan-600 pb-4 mb-4 drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)]">
                        Big Nickel<br>Token Slots
                    </h1>
                    <p class="mt-2 text-2xl font-bold text-white tracking-wide">
                        Balance: <span class="text-green-400 drop-shadow-md">${state.balance} Tokens</span>
                    </p>
                    ${state.userId ? `<p class="mt-1 text-xs text-slate-400 font-mono">User ID: ${state.userId}</p>` : ''}
                </header>
                <nav class="flex justify-between space-x-2 mb-8 p-2 bg-slate-900 rounded-lg shadow-inner">
                    ${renderGameButton('Slots')}
                    ${renderGameButton('Roulette')}
                    ${renderGameButton('Dice')}
                </nav>
            `;

            if (state.isLoading) {
                gameContent = renderLoading();
            } else if (state.error) {
                gameContent = renderError(state.error);
            } else {
                switch (state.currentGame) {
                    case 'slots':
                        gameContent = renderSlotMachine();
                        break;
                    case 'roulette':
                        gameContent = renderRoulette();
                        break;
                    case 'dice':
                        gameContent = renderDiceRoll();
                        break;
                    default:
                        gameContent = '<div class="text-white">Select a game to begin!</div>';
                }
            }

            const footer = `
                <footer class="mt-8 pt-4 border-t border-slate-700 text-center text-xs text-slate-500">
                    <p>Big Nickel Simulation - Funds are not real currency. Created by Gemini.</p>
                </footer>
            `;

            appContainer.innerHTML = header + gameContent + footer;
        };
        
        const renderGameButton = (name) => {
            const lowerName = name.toLowerCase();
            const isActive = state.currentGame === lowerName;
            return `
                <button
                    onclick="window.setCurrentGame('${lowerName}')"
                    class="flex-1 py-2 rounded-lg font-bold tracking-wider uppercase transition-all duration-200 ${
                        isActive
                            ? 'bg-cyan-600 text-slate-900 shadow-xl'
                            : 'bg-slate-700 text-white hover:bg-slate-600'
                    }"
                >
                    ${name}
                </button>
            `;
        };


        // --- Initialization ---

        const initializeFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase Configuration is missing from the environment.");
                updateState({ error: "Firebase not initialized. Configuration data is missing.", isLoading: false });
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                updateState({ error: "Firebase initialization failed. Check browser console.", isLoading: false });
                console.error("Firebase initialization failed:", e);
                return;
            }

            onAuthStateChanged(auth, async (user) => {
                let uid = user?.uid;

                if (!user) {
                    try {
                        if (initialAuthToken) {
                            const credential = await withRetry(() => signInWithCustomToken(auth, initialAuthToken));
                            uid = credential.user.uid;
                        } else {
                            const credential = await withRetry(() => signInAnonymously(auth));
                            uid = credential.user.uid;
                        }
                    } catch (e) {
                        console.error("Authentication failed:", e);
                        updateState({ error: "Failed to sign in. Cannot access user data.", isLoading: false });
                        return;
                    }
                }

                if (uid) {
                    updateState({ userId: uid, isAuthReady: true });
                    setupFirestoreListener(uid);
                }
            });
        };

        const setupFirestoreListener = (uid) => {
            const fundsDocRef = getFundsDocRef(uid);
            onSnapshot(fundsDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    updateState({ balance: data.balance, isLoading: false, error: null });
                } else {
                    console.log("User fund document not found. Initializing balance.");
                    try {
                        await setDoc(fundsDocRef, { balance: INITIAL_BALANCE, userId: uid });
                        updateState({ balance: INITIAL_BALANCE, isLoading: false, error: null });
                    } catch (e) {
                        console.error("Failed to initialize balance:", e);
                        updateState({ error: "Failed to initialize user funds. Check Security Rules.", isLoading: false });
                    }
                }
            }, (e) => {
                console.error("Firestore subscription error:", e);
                updateState({ error: "Failed to connect to funds database. Check console for security rule errors.", isLoading: false });
            });
        };

        initializeFirebase();
        renderApp();

    </script>
</body>
</html>
